package net.hillsdon.reviki.wiki.renderer.creole.ast;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import net.hillsdon.reviki.wiki.renderer.macro.Macro;

/**
 * A node in the abstract syntax tree produced by the Creole parser.
 * 
 * @author msw
 */
public abstract class ASTNode {
  /**
   * Most elements have a consistent CSS class. Links and images are an
   * exception (as can be seen in their implementation), as their HTML is
   * generated by a link handler.
   */
  public static final String CSS_CLASS_ATTR = "class='wiki-content'";

  /**
   * Most elements have a tag. Only two (plaintext and raw) don't.
   * 
   * TODO: It feels a bit wrong to have elements with no tags, figure out a
   * nicer representation.
   */
  protected final String tag;

  /**
   * The immediate contents of the node (may be null). Is rendered before any
   * children in the output.
   */
  protected ASTNode body;

  /**
   * The child elements of the node (may be null).
   */
  protected List<ASTNode> children;

  /**
   * Construct a new AST node.
   * 
   * @param tag The tag (optional). If there is no tag, toXHTML *must* be
   *          overridden, and handled appropriately for the node.
   * @param body The immediate content of the node (may be null).
   * @param children Any child elements of the node (may be null).
   */
  public ASTNode(String tag, ASTNode body, List<ASTNode> children) {
    this.tag = tag;
    this.body = body;

    if (children == null) {
      this.children = new ArrayList<ASTNode>();
    }
    else {
      this.children = children;
    }
  }

  /** See {@link #ASTNode(String, ASTNode, List)  */
  public ASTNode(String tag, ASTNode body) {
    this(tag, body, null);
  }

  /** See {@link #ASTNode(String, ASTNode, List)  */
  public ASTNode(String tag, List<ASTNode> children) {
    this(tag, null, children);
  }

  /** See {@link #ASTNode(String, ASTNode, List)  */
  public ASTNode(String tag) {
    this(tag, null, null);
  }

  /**
   * Return a list of the children of this node. This includes the body (if any)
   * as the first element of the list. This will not be null.
   */
  public List<ASTNode> getChildren() {
    ArrayList<ASTNode> children = new ArrayList<ASTNode>();
    if (body != null)
      children.add(body);
    children.addAll(this.children);
    return Collections.unmodifiableList(children);
  }

  /**
   * Produce a valid XHTML representation (assuming valid implementations of
   * toXHTML for all direct and indirect children) of the node.
   */
  public String toXHTML() {
    if (getChildren().isEmpty() || (body != null && body.toXHTML().equals("") && children.isEmpty())) {
      return "<" + tag + " " + CSS_CLASS_ATTR + " />";
    }

    String out = "<" + tag + " " + CSS_CLASS_ATTR + ">";

    for (ASTNode node : getChildren()) {
      out += node.toXHTML();
    }

    out += "</" + tag + ">";

    return out;
  }

  /**
   * Expand macros contained within this node and its children, returning the
   * modified node.
   * 
   * @param macro The list of macros
   * @return The possibly modified node. If the node was not a macro, `this`
   *         will be returned, however if `this` is returned it cannot be
   *         assumed that none of the node's children contained macros.
   */
  public ASTNode expandMacros(List<Macro> macros) {
    if (body != null) {
      body = body.expandMacros(macros);
    }

    List<ASTNode> adoptees = new ArrayList<ASTNode>();

    for (ASTNode child : children) {
      adoptees.add(child.expandMacros(macros));
    }

    children = adoptees;

    return this;
  }
}
